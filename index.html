<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¶”ìˆ˜ê°ì‚¬ë„¤ì»·</title>
    <style>
        body { font-family: 'Malgun Gothic', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; color: #333; }
        .screen { display: none; width: 100%; max-width: 1000px; padding: 20px; box-sizing: border-box; text-align: center; }
        .screen.active { display: block; }
        h1, h2 { color: #2c3e50; }
        button { background-color: #27ae60; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: background-color .3s; margin: 5px; }
        button:hover { background-color: #229954; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        #frame-selection .frame-options { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        #frame-selection .frame-row { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        #frame-selection img { box-sizing: border-box; width: 200px; border: 3px solid transparent; border-radius: 10px; cursor: pointer; transition: border-color .3s, transform .3s; background-color: #fff; }
        #frame-selection img:hover { border-color: #27ae60; transform: scale(1.05); }
        #video-container { position: relative; width: 100%; max-width: 500px; margin: 0 auto; }
        
        #capture-screen video { 
            width: 100%; 
            border-radius: 10px; 
            background-color: #000; 
            display: block; 
        }

        #countdown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; font-size: 150px; font-weight: 700; color: #fff; text-shadow: 2px 2px 8px rgba(0,0,0,.8); -webkit-text-stroke: 2px #000; z-index: 20; }
        
        #capture-progress-overlay {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 36px; /* ì¹´ìš´íŠ¸ë‹¤ìš´(150px)ë³´ë‹¤ ì‘ê²Œ ì„¤ì • */
            font-weight: 700;
            color: #fff;
            text-shadow: 1px 1px 4px rgba(0,0,0,.8);
            -webkit-text-stroke: 1px #000;
            display: none; /* JSë¡œ ì œì–´ */
            z-index: 10; /* ë¹„ë””ì˜¤ ìœ„ì—, ì¹´ìš´íŠ¸ë‹¤ìš´ë³´ë‹¤ëŠ” ì•„ë˜ì— */
        }

        #capture-controls { margin-top: 15px; }
        #stop-capture-btn { background-color: #e74c3c; }
        
        #thumbnails {
            display: flex;
            flex-wrap: wrap; /* ë˜í•‘ í—ˆìš© */
            gap: 10px;
            justify-content: center; /* ì¤‘ì•™ ì •ë ¬ */
            margin-top: 15px;
            min-height: 80px; /* ìµœì†Œ ë†’ì´ (padding + slot height) */
            height: auto; /* ë‚´ìš©ì— ë”°ë¼ ë†’ì´ ìë™ ì¡°ì ˆ */
            padding: 10px;
            background: #fff;
            border-radius: 5px;
        }

        /* ì¸ë„¤ì¼ ìŠ¬ë¡¯ (placeholder) */
        .thumbnail-slot {
            width: 80px;
            height: 60px;
            background-color: #eee;
            border-radius: 5px;
            border: 2px dashed #ccc;
            flex-shrink: 0;
            box-sizing: border-box; 
        }

        /* ì¸ë„¤ì¼ ìŠ¬ë¡¯ì— ì±„ì›Œì§„ ì´ë¯¸ì§€ */
        .thumbnail-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 3px;
            display: block;
        }

        #photo-selection .photo-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin: 20px 0; }
        #photo-selection .photo-item img { width: 100%; border-radius: 5px; display: block; border: 4px solid transparent; cursor: pointer; transition: border-color .2s; }
        #photo-selection .photo-item img.selected { border-color: #27ae60; }
        #editor-screen canvas { border: 2px solid #ccc; border-radius: 5px; cursor: grab; max-width: 100%; height: auto; touch-action: none; }
        .instructions { background-color: #e8f8f5; border: 1px solid #a3e4d7; color: #138d75; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .footer { margin-top: 40px; font-size: 14px; color: #888; }
        #camera-controls { margin-bottom: 10px; }
        #camera-select { padding: 8px; border-radius: 5px; border: 1px solid #ccc; font-size: 14px; }
    </style>
</head>
<body>

    <div id="frame-selection" class="screen active">
        <h1>ğŸ’– ì¶”ìˆ˜ê°ì‚¬ë„¤ì»· ğŸ’–</h1>
        <p class="instructions">ë§ˆìŒì— ë“œëŠ” í”„ë ˆì„ì„ ì„ íƒí•˜ì„¸ìš”.</p>
        <div class="frame-options">
            <div class="frame-row">
                <img src="1ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 1" data-frame="1ë²ˆ í”„ë ˆì„.png" data-photos="2" data-photo-slots="thanksgiving_4_slots">
                <img src="2ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 2" data-frame="2ë²ˆ í”„ë ˆì„.png" data-photos="2" data-photo-slots="thanksgiving_4_slots">
                <img src="3ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 3" data-frame="3ë²ˆ í”„ë ˆì„.png" data-photos="2" data-photo-slots="thanksgiving_4_slots">
                <img src="4ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 4" data-frame="4ë²ˆ í”„ë ˆì„.png" data-photos="2" data-photo-slots="thanksgiving_4_slots">
            </div>
            <div class="frame-row">
                <img src="5ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 5" data-frame="5ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="thanksgiving_8_slots">
                <img src="6ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 6" data-frame="6ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="thanksgiving_8_slots">
                <img src="7ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 7" data-frame="7ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="thanksgiving_8_slots">
                <img src="8ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 8" data-frame="8ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="thanksgiving_8_slots">
            </div>
            </div>
        <p class="footer">ì œì‘: ì¸ì²œì‹ ì •ì´ˆë“±í•™êµ ê¹€ë³‘ì„ ì„ ìƒë‹˜ (scimania@daum.net)</p>
    </div>

    <div id="capture-screen" class="screen">
        <h2>ğŸ“· ì‚¬ì§„ ì´¬ì˜ (<span id="capture-count">0</span>/<span id="required-capture-count">0</span>)</h2>
        <p class="instructions">í”„ë ˆì„ì— í•„ìš”í•œ <b id="required-photos-count-capture">0</b>ì¥ì˜ ì‚¬ì§„ì„ ì´¬ì˜í•©ë‹ˆë‹¤.</p>
        
        <div id="camera-controls">
            <label for="camera-select">ì¹´ë©”ë¼ ì„ íƒ: </label>
            <select id="camera-select"></select>
        </div>
        <div id="video-container">
            <video id="webcam" autoplay playsinline></video>
            <div id="countdown-overlay"></div>
            <div id="capture-progress-overlay"></div>
        </div>
        <div id="capture-controls">
            <button id="manual-capture-btn">ìˆ˜ë™ì´¬ì˜</button>
            <button id="auto-capture-1s-btn">1ì´ˆ ìë™ì´¬ì˜</button>
            <button id="auto-capture-3s-btn">3ì´ˆ ìë™ì´¬ì˜</button>
            <button id="auto-capture-5s-btn">5ì´ˆ ìë™ì´¬ì˜</button>
            <button id="stop-capture-btn" style="display:none">ì´¬ì˜ ì¤‘ì§€</button>
        </div>
        <button id="next-to-selection-btn" disabled style="display:none;">ì‚¬ì§„ ì„ íƒí•˜ê¸°</button>
        <h3>ì´¬ì˜ëœ ì‚¬ì§„ ëª©ë¡</h3>
        <div id="thumbnails"></div>
    </div>

    <div id="photo-selection" class="screen">
        <h2>ğŸ–¼ï¸ ì‚¬ì§„ ì„ íƒ</h2>
        <p class="instructions">í”„ë ˆì„ì— ë„£ì„ <b id="required-photos-count"></b>ì¥ì˜ ì‚¬ì§„ì„ ì„ íƒí•œ í›„, 'í¸ì§‘ í™”ë©´ìœ¼ë¡œ' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
        <div id="photo-grid-container" class="photo-grid"></div>
        <button id="next-to-editor-btn">í¸ì§‘ í™”ë©´ìœ¼ë¡œ</button>
    </div>

    <div id="editor-screen" class="screen">
        <h2>ğŸ¨ ì‚¬ì§„ í¸ì§‘</h2>
        <p class="instructions">ì‚¬ì§„ì„ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ë¥¼ ì˜®ê¸°ê³ , ëª¨ì„œë¦¬ í•¸ë“¤ì´ë‚˜ ë‹¨ì¶•í‚¤(W/A/S/D)ë¡œ í¬ê¸°ì™€ ë°©í–¥ì„ ì¡°ì ˆí•˜ì„¸ìš”.</p>
        <canvas id="canvas"></canvas>
        <div class="controls" style="margin-top:20px">
            <button id="download-btn">ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
            <button id="redo-capture-btn">ë‹¤ì‹œ ì´¬ì˜</button>
            <button id="restart-btn">ì²˜ìŒìœ¼ë¡œ</button>
        </div>
    </div>

    <audio id="shutter-sound" src="shutter.mp3" preload="auto"></audio>

    <script>
        const screens = document.querySelectorAll('.screen');
        const frameSelectionScreen = document.getElementById('frame-selection');
        const captureScreen = document.getElementById('capture-screen');
        const photoSelectionScreen = document.getElementById('photo-selection');
        const editorScreen = document.getElementById('editor-screen');
        const webcamElement = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const captureCountSpan = document.getElementById('capture-count');
        const manualCaptureBtn = document.getElementById('manual-capture-btn');
        const autoCapture1sBtn = document.getElementById('auto-capture-1s-btn');
        const autoCapture3sBtn = document.getElementById('auto-capture-3s-btn');
        const autoCapture5sBtn = document.getElementById('auto-capture-5s-btn');
        const stopCaptureBtn = document.getElementById('stop-capture-btn');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const thumbnailsContainer = document.getElementById('thumbnails');
        
        const captureProgressOverlay = document.getElementById('capture-progress-overlay');

        const downloadBtn = document.getElementById('download-btn');
        const redoCaptureBtn = document.getElementById('redo-capture-btn');
        const restartBtn = document.getElementById('restart-btn');
        const shutterSound = document.getElementById('shutter-sound');
        const cameraSelect = document.getElementById('camera-select');

        const requiredCaptureCountSpan = document.getElementById('required-capture-count');
        const requiredPhotosCountCapture = document.getElementById('required-photos-count-capture');

        let state = {
            selectedFrameSrc: null,
            selectedFrameType: null,
            requiredPhotos: 0, // ì´¬ì˜í•´ì•¼ í•  ì‚¬ì§„ ìˆ˜ (N/2)
            capturedPhotos: [],
            editedPhotos: [],
            frameImage: null
        };

        let activePhoto = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let dragStartX, dragStartY;
        const handleSize = 16;
        let autoCaptureTimer = null;
        let countdownInterval = null;

        // (JS ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ)
        const frameSlots = {
            thanksgiving_4_slots: [
                [0.0589, 0.0504, 0.4203, 0.3817], // 1ë²ˆ ìŠ¬ë¡¯ (ì¢Œìƒ)
                [0.5236, 0.0504, 0.4203, 0.3817], // 2ë²ˆ ìŠ¬ë¡¯ (ìš°ìƒ)
                [0.0589, 0.4456, 0.4203, 0.3817], // 3ë²ˆ ìŠ¬ë¡¯ (ì¢Œí•˜)
                [0.5236, 0.4456, 0.4203, 0.3817]  // 4ë²ˆ ìŠ¬ë¡¯ (ìš°í•˜)
            ],
            thanksgiving_8_slots: [
                [0.0556, 0.0492, 0.4220, 0.1897], // 1ë²ˆ ìŠ¬ë¡¯
                [0.5236, 0.0492, 0.4220, 0.1897], // 2ë²ˆ ìŠ¬ë¡¯
                [0.0556, 0.2456, 0.4220, 0.1897], // 3ë²ˆ ìŠ¬ë¡¯
                [0.5236, 0.2456, 0.4220, 0.1897], // 4ë²ˆ ìŠ¬ë¡¯
                [0.0556, 0.4433, 0.4220, 0.1897], // 5ë²ˆ ìŠ¬ë¡¯
                [0.5236, 0.4433, 0.4220, 0.1897], // 6ë²ˆ ìŠ¬ë¡¯
                [0.0556, 0.6385, 0.4220, 0.1897], // 7ë²ˆ ìŠ¬ë¡¯
                [0.5236, 0.6385, 0.4220, 0.1897]  // 8ë²ˆ ìŠ¬ë¡¯
            ]
        };

        Object.keys(frameSlots).forEach(key => {
            frameSlots[key].forEach(slot => {
                if (slot.length < 5) {
                    slot.push('square');
                }
            });
        });

        function showScreen(screenId) {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        frameSelectionScreen.addEventListener('click', (e) => {
            if (e.target.tagName === 'IMG') {
                state.selectedFrameSrc = e.target.dataset.frame;
                state.selectedFrameType = e.target.dataset.photoSlots;
                state.requiredPhotos = parseInt(e.target.dataset.photos); 
                initializeCameraAndList();
            }
        });

        async function initializeCameraAndList() {
            try {
                const initialStream = await navigator.mediaDevices.getUserMedia({ video: true });
                webcamElement.srcObject = initialStream;
                showScreen('capture-screen');

                captureProgressOverlay.textContent = `0/${state.requiredPhotos}`;
                captureProgressOverlay.style.display = 'block';

                thumbnailsContainer.innerHTML = ""; 
                for (let i = 0; i < state.requiredPhotos; i++) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'thumbnail-slot';
                    thumbnailsContainer.appendChild(placeholder);
                }

                requiredCaptureCountSpan.textContent = state.requiredPhotos;
                requiredPhotosCountCapture.textContent = state.requiredPhotos;

                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                const currentTrack = initialStream.getVideoTracks()[0];
                const currentSettings = currentTrack.getSettings();
                const currentDeviceInUse = currentSettings.deviceId;
                let isInitialCameraRear = false; 

                cameraSelect.innerHTML = ''; 
                if (videoDevices.length === 0) {
                    alert('ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë©”ë¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    const label = device.label || `ì¹´ë©”ë¼ ${index + 1}`;
                    option.text = label;
                    
                    if (device.deviceId === currentDeviceInUse) {
                        option.selected = true; 
                        if (label.toLowerCase().includes('back') || label.toLowerCase().includes('rear') || label.toLowerCase().includes('í›„ë©´')) {
                            isInitialCameraRear = true;
                        }
                    }
                    cameraSelect.appendChild(option);
                });

                if (isInitialCameraRear) {
                    webcamElement.style.transform = 'scaleX(1)';
                } else {
                    webcamElement.style.transform = 'scaleX(-1)';
                }

            } catch (err) {
                console.error("ì›¹ìº  ì ‘ê·¼ ì˜¤ë¥˜:", err);
                alert("ì›¹ìº ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.\n\n(ì°¸ê³ : ì´ í”„ë¡œê·¸ë¨ì€ 'ì„œë²„' í™˜ê²½ì—ì„œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤. 'file://' ê²½ë¡œì—ì„œëŠ” ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)");
            }
        }
        
        async function startWebcam(deviceId) {
            try {
                if (webcamElement.srcObject) {
                    webcamElement.srcObject.getTracks().forEach(track => track.stop());
                }
                const constraints = { video: { deviceId: { exact: deviceId } } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                webcamElement.srcObject = stream;

                const selectedOption = cameraSelect.options[cameraSelect.selectedIndex];
                const label = selectedOption.text.toLowerCase();
                const isRearCamera = label.includes('back') || label.includes('rear') || label.includes('í›„ë©´');

                if (isRearCamera) {
                    webcamElement.style.transform = 'scaleX(1)'; 
                } else {
                    webcamElement.style.transform = 'scaleX(-1)';
                }

            } catch (err) {
                console.error("ì›¹ìº  ì „í™˜ ì˜¤ë¥˜:", err);
                alert("ì„ íƒí•œ ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            }
        }

        cameraSelect.addEventListener('change', () => {
            startWebcam(cameraSelect.value);
        });
        
        function capturePhoto() {
            if (state.capturedPhotos.length >= state.requiredPhotos) return;
            
            shutterSound.currentTime = 0;
            shutterSound.play();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = webcamElement.videoWidth;
            tempCanvas.height = webcamElement.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');

            const selectedOption = cameraSelect.options[cameraSelect.selectedIndex];
            const label = selectedOption.text.toLowerCase();
            const isRearCamera = label.includes('back') || label.includes('rear') || label.includes('í›„ë©´');

            if (isRearCamera) {
            } else {
            }

            tempCtx.drawImage(webcamElement, 0, 0, tempCanvas.width, tempCanvas.height);
            const dataUrl = tempCanvas.toDataURL('image/jpeg');
            state.capturedPhotos.push(dataUrl);
            const img = document.createElement('img');
            img.src = dataUrl;
            
            const slots = thumbnailsContainer.querySelectorAll('.thumbnail-slot');
            const slotToFill = slots[state.capturedPhotos.length - 1]; 
            if (slotToFill) {
                slotToFill.innerHTML = ''; 
                slotToFill.appendChild(img);
                slotToFill.style.border = '2px solid #27ae60'; 
            }
            
            captureProgressOverlay.textContent = `${state.capturedPhotos.length}/${state.requiredPhotos}`;
            captureCountSpan.textContent = state.capturedPhotos.length;

            if (state.capturedPhotos.length === state.requiredPhotos) {
                toggleCaptureButtons(true); 
                stopAutoCapture(); 
                
                if (webcamElement.srcObject) {
                    webcamElement.srcObject.getTracks().forEach(track => track.stop());
                    webcamElement.srcObject = null; 
                }

                captureProgressOverlay.style.display = 'none';
                
                initEditor(state.capturedPhotos); 
            }
        }

        function runCountdown(seconds, callback) {
            let count = seconds;
            countdownOverlay.style.display = 'flex';
            const updateCountdown = () => {
                countdownOverlay.textContent = count;
                if (count < 1) {
                    clearInterval(countdownInterval);
                    countdownOverlay.style.display = 'none';
                    callback();
                }
                count--;
            };
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        function startAutoCapture(intervalSeconds) {
            if (state.capturedPhotos.length >= state.requiredPhotos) return; 
            toggleCaptureButtons(true);
            stopCaptureBtn.style.display = 'inline-block';
            
            const captureLoop = () => {
                if (state.capturedPhotos.length >= state.requiredPhotos) { 
                    stopAutoCapture();
                    return;
                }
                runCountdown(intervalSeconds, () => {
                    capturePhoto();
                    if (state.capturedPhotos.length < state.requiredPhotos) { 
                        autoCaptureTimer = setTimeout(captureLoop, 1000);
                    }
                });
            };
            captureLoop();
        }

        function stopAutoCapture() {
            clearTimeout(autoCaptureTimer);
            clearInterval(countdownInterval);
            autoCaptureTimer = null;
            countdownInterval = null;
            countdownOverlay.style.display = 'none';
            stopCaptureBtn.style.display = 'none';
            toggleCaptureButtons(state.capturedPhotos.length >= state.requiredPhotos);
        }

        function toggleCaptureButtons(disabled) {
            manualCaptureBtn.disabled = disabled;
            autoCapture1sBtn.disabled = disabled;
            autoCapture3sBtn.disabled = disabled;
            autoCapture5sBtn.disabled = disabled;
        }

        manualCaptureBtn.addEventListener('click', capturePhoto);
        autoCapture1sBtn.addEventListener('click', () => startAutoCapture(1));
        autoCapture3sBtn.addEventListener('click', () => startAutoCapture(3));
        autoCapture5sBtn.addEventListener('click', () => startAutoCapture(5));
        stopCaptureBtn.addEventListener('click', stopAutoCapture);

        function initEditor(selectedPhotos) { 
            const frameImg = new Image();
            state.frameImage = frameImg;
            frameImg.src = state.selectedFrameSrc;
            frameImg.onload = () => {
                canvas.width = frameImg.width;
                canvas.height = frameImg.height;

                const photoPromises = selectedPhotos.map(src => new Promise(resolve => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => resolve(img);
                }));

                Promise.all(photoPromises).then(images => {
                    state.editedPhotos = []; 
                    const allSlots = frameSlots[state.selectedFrameType]; 

                    images.forEach((img, i) => {
                        const slotIndex1 = i * 2;
                        const slotIndex2 = i * 2 + 1;

                        if (!allSlots[slotIndex1] || !allSlots[slotIndex2]) {
                            console.error(`ìŠ¬ë¡¯ ì •ì˜ ì˜¤ë¥˜: ${state.selectedFrameType}ì˜ ${slotIndex1}, ${slotIndex2} ìŠ¬ë¡¯ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                            return;
                        }

                        const slot1 = allSlots[slotIndex1];
                        const slot2 = allSlots[slotIndex2];

                        const createPhotoObject = (slotData) => {
                            const slotX = slotData[0] * canvas.width;
                            const slotY = slotData[1] * canvas.height;
                            const slotWidth = slotData[2] * canvas.width;
                            const slotHeight = slotData[3] * canvas.height;
                            const slotType = slotData[4];
                            
                            let newWidth = slotWidth;
                            let newHeight = slotWidth * (img.height / img.width);
                            if (newHeight < slotHeight) {
                                newHeight = slotHeight;
                                newWidth = slotHeight * (img.width / img.height);
                            }

                            return {
                                img: img, 
                                x: slotX + (slotWidth - newWidth) / 2,
                                y: slotY + (slotHeight - newHeight) / 2,
                                width: newWidth,
                                height: newHeight,
                                rotation: 0,
                                originalSlot: { x: slotX, y: slotY, width: slotWidth, height: slotHeight, type: slotType }
                            };
                        };

                        state.editedPhotos.push(createPhotoObject(slot1));
                        state.editedPhotos.push(createPhotoObject(slot2));
                    });
                    
                    drawCanvas();
                    showScreen('editor-screen');
                });
            };
            if (frameImg.complete) frameImg.onload();
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            state.editedPhotos.forEach(photo => {
                ctx.save();
                const slot = photo.originalSlot;
                
                if (slot.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(slot.x + slot.width / 2, slot.y + slot.height / 2, Math.min(slot.width, slot.height) / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();
                } else { // square
                    ctx.beginPath();
                    ctx.rect(slot.x, slot.y, slot.width, slot.height);
                    ctx.closePath();
                    ctx.clip();
                }

                ctx.translate(photo.x + photo.width / 2, photo.y + photo.height / 2);
                ctx.rotate(photo.rotation);
                ctx.translate(-(photo.x + photo.width / 2), -(photo.y + photo.height / 2));
                ctx.drawImage(photo.img, photo.x, photo.y, photo.width, photo.height);
                ctx.restore();
            });

            if (state.frameImage && state.frameImage.complete) {
                ctx.drawImage(state.frameImage, 0, 0, canvas.width, canvas.height);
            }

            if (activePhoto) {
                drawHandles(activePhoto);
            }
        }

        function drawHandles(photo) {
            const centerX = photo.x + photo.width / 2;
            const centerY = photo.y + photo.height / 2;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(photo.rotation);
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 4;
            ctx.strokeRect(-photo.width / 2, -photo.height / 2, photo.width, photo.height);
            
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(photo.width / 2 - handleSize, photo.height / 2 - handleSize, handleSize * 2, handleSize * 2);

            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(-photo.width / 2, -photo.height / 2, handleSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function getTransformedCoords(point, photo) {
            const dx = point.x - (photo.x + photo.width / 2);
            const dy = point.y - (photo.y + photo.height / 2);
            const angle = -photo.rotation;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return {
                x: rotatedX + (photo.x + photo.width / 2),
                y: rotatedY + (photo.y + photo.height / 2)
            };
        }
        
        function isOverHandle(photo, point, handleType) {
            const h_size = handleSize * 2;
            if (handleType === 'resize') {
                return point.x > photo.x + photo.width - h_size && point.x < photo.x + photo.width &&
                       point.y > photo.y + photo.height - h_size && point.y < photo.y + photo.height;
            } else if (handleType === 'rotate') {
                return point.x > photo.x && point.x < photo.x + h_size &&
                       point.y > photo.y && point.y < photo.y + h_size;
            }
        }

        function handlePointerDown(e) {
            e.preventDefault();
            const pos = getPointerPos(e);

            if (activePhoto) {
                const transformedPos = getTransformedCoords(pos, activePhoto);
                if (isOverHandle(activePhoto, transformedPos, 'resize')) {
                    isResizing = true;
                    canvas.style.cursor = 'se-resize';
                    return;
                }
                if (isOverHandle(activePhoto, transformedPos, 'rotate')) {
                    isRotating = true;
                    canvas.style.cursor = 'crosshair';
                    return;
                }
            }
            
            activePhoto = null;
            isDragging = false;
            isResizing = false;
            isRotating = false;

            for (let i = state.editedPhotos.length - 1; i >= 0; i--) {
                const photo = state.editedPhotos[i];
                const transformedPos = getTransformedCoords(pos, photo);
                if (transformedPos.x >= photo.x && transformedPos.x <= photo.x + photo.width &&
                    transformedPos.y >= photo.y && transformedPos.y <= photo.y + photo.height) {
                    activePhoto = photo;
                    isDragging = true;
                    dragStartX = pos.x - photo.x;
                    dragStartY = pos.y - photo.y;
                    canvas.style.cursor = 'grabbing';
                    state.editedPhotos.splice(i, 1);
                    state.editedPhotos.push(photo); 
                    break;
                }
            }
            drawCanvas();
        }

        function handlePointerMove(e) {
            if (!activePhoto) return;
            e.preventDefault();
            const pos = getPointerPos(e);
            
            if (isDragging) {
                activePhoto.x = pos.x - dragStartX;
                activePhoto.y = pos.y - dragStartY;
            } else if (isResizing) {
                const transformedPos = getTransformedCoords(pos, activePhoto);
                const newWidth = transformedPos.x - activePhoto.x;
                const newHeight = newWidth * (activePhoto.img.height / activePhoto.img.width);
                if (newWidth > 20) {
                    activePhoto.width = newWidth;
                    activePhoto.height = newHeight;
                }
            } else if (isRotating) {
                const centerX = activePhoto.x + activePhoto.width / 2;
                const centerY = activePhoto.y + activePhoto.height / 2;
                activePhoto.rotation = Math.atan2(pos.y - centerY, pos.x - centerX);
            }
            drawCanvas();
        }

        function handlePointerUp(e) {
            isDragging = false;
            isResizing = false;
            isRotating = false;
            canvas.style.cursor = 'grab';
        }

        document.addEventListener('keydown', e => {
            if (!activePhoto) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            const scaleFactor = 1.05;
            const rotateAngle = Math.PI / 180 * 5; 
            let needsRedraw = true;

            switch(e.key.toLowerCase()) {
                case 'w':
                    activePhoto.width *= scaleFactor;
                    activePhoto.height *= scaleFactor;
                    break;
                case 's':
                    activePhoto.width /= scaleFactor;
                    activePhoto.height /= scaleFactor;
                    break;
                case 'a':
                    activePhoto.rotation -= rotateAngle;
                    break;
                case 'd':
                    activePhoto.rotation += rotateAngle;
                    break;
                default:
                    needsRedraw = false;
            }

            if (needsRedraw) {
                e.preventDefault();
                drawCanvas();
            }
        });

        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mouseleave', handlePointerUp);

        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('touchcancel', handlePointerUp);

        downloadBtn.addEventListener('click', () => {
            activePhoto = null;
            drawCanvas();
            const now = new Date();
            const timestamp = now.getFullYear().toString() +
                              (now.getMonth() + 1).toString().padStart(2, '0') +
                              now.getDate().toString().padStart(2, '0') + '_' +
                              now.getHours().toString().padStart(2, '0') +
                              now.getMinutes().toString().padStart(2, '0') +
                              now.getSeconds().toString().padStart(2, '0');
            link.download = `ì¶”ìˆ˜ê°ì‚¬ë„¤ì»·_${timestamp}.png`; 
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        redoCaptureBtn.addEventListener('click', () => {
            stopAutoCapture();

            if (webcamElement.srcObject) {
                webcamElement.srcObject.getTracks().forEach(track => track.stop());
                webcamElement.srcObject = null; 
            }
            
            state.capturedPhotos = [];
            state.editedPhotos = [];
            state.frameImage = null; 
            
            activePhoto = null;
            isDragging = false;
            isResizing = false;
            isRotating = false;

            captureCountSpan.textContent = "0";
            thumbnailsContainer.innerHTML = ""; 
            toggleCaptureButtons(false);
            
            initializeCameraAndList(); 
        });

        restartBtn.addEventListener('click', () => {
            stopAutoCapture();
            if (webcamElement.srcObject) {
                webcamElement.srcObject.getTracks().forEach(track => track.stop());
                webcamElement.srcObject = null; 
            }
            state = {
                selectedFrameSrc: null,
                selectedFrameType: null,
                requiredPhotos: 0,
                capturedPhotos: [],
                editedPhotos: [],
                frameImage: null
            };
            activePhoto = null;
            isDragging = isResizing = isRotating = false;
            captureCountSpan.textContent = "0";
            
            requiredCaptureCountSpan.textContent = "0";
            requiredPhotosCountCapture.textContent = "0";

            captureProgressOverlay.style.display = 'none';
            captureProgressOverlay.textContent = '';

            toggleCaptureButtons(false);
            
            thumbnailsContainer.innerHTML = ""; 
            showScreen('frame-selection');
        });

        showScreen('frame-selection');
    </script>
</body>
</html>